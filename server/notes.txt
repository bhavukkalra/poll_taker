app.get('route_info', (handler_function))

app.use((handler_function)) // whole block is a middleware

-----------------------------------------------------------------------------------
Middleware

app.use
route = /login
Login - valid token or invalid token 


route = /login
Authenticate Login(middleware)  ====> PLACED BEFORE route and also called immediately after specified route is accessed 
then remaining route ex (app.post('/login'), (req, res)) is executed

THERE COULD ALSO BE COMMON MIDDLEWARES


Admin Dashboard

Middleware will first check if the user has a valid token (i.e coming from login page with correct user id and pass)
only then will be allowed to see admin dashboard 
if not redirect to login page

-----------------------------------------------------------------------------------


info about CORS (Cross origin Resource Sharing) => to handle cross origin requests
https://en.wikipedia.org/wiki/Cross-origin_resource_sharing

npm dotenv => for hiding enviroment variables e.x API KEYS

To use your own promise library(eg Bluebird with mongoose) use
mongoose.Promises = Bluebird


mongoose.SchemaType =>
SchemaType doesn't actually create MongoDB ObjectIds, it is just a configuration for a path in a schema.

i.e 
mongoose.ObjectId !== mongoose.Types.ObjectId


module.exports.User = require('./user');
module.exports.Poll = require('./poll');

// It allows us to use db variable in our application
// ie const db = require('./models') as
// db.User and db.Poll instead of first importing individual schema
// like const User = require('./models/user'); ex_usage = User.create()

// but now we can use as db.User and db.Poll with single import
// const db = require('./models)


git reset HEAD~1 (--hard flag could be added)

async await syntactic sugar


-----------------------------------------------------------------------------------
BEFORE STORING THE USERS ENCRYPTION IS DONE
//here function() keyword must be used instead of arrow function
// because of this keyword 

REGULAR FUNCTIONS => this keyword represented the object that called the function, 
which could be the window, the document, a button or whatever.

() => this keyword always represents the object that (defined the arrow function)/(it sowner) i.e it
WILL HAVE GLOBAL SCOPE

IF want dynamic this -> use function() othe wise () =>

REFERENCE = https://www.w3schools.com/js/js_arrow_function.asp#:~:text=In%20short%2C%20with%20arrow%20functions,that%20defined%20the%20arrow%20function.

------------------------------------------------------------------------------------------

FROM DOCS ---
userSchema.pre('save', async function(next){

}

Middleware (also called pre and post hooks) are functions which are passed control during execution of asynchronous functions
Mongoose has 4 types of middleware: document middleware, model middleware, aggregate middleware, and query middleware

SAVE IS A DOCCUMENT Middleware -> where this referes to doccument
Pre middleware functions are executed one after another, when each middleware calls next.

NOTE -
var schema = new Schema(..);
schema.pre('save', function(next) {
  if (foo()) {
    console.log('calling next!');
    // `return next();` will make sure the rest of this function doesn't run
    /*return*/ next();
  }
  // Unless you comment out the `return` above, 'after next' will print
  console.log('after next');
});
----------------------------------------------------------------------------------------------

in handlers auth.js  => exports.login(req,res, next) 

and in handlers/index.js => 

module.exports = {
  ...require('./auth')
}

as we are spreading it out(all handlers for auth route) and exporting each as module.exports

--------------------------------------------------------------------------------------

 ... rest and spread operator
 https://dev.to/sagar/three-dots---in-javascript-26ci

 -----------------------------------------------------------------------------------
 EXPRESS.ROUTER

 Use the express.Router class to create modular, mountable route handlers. A Router instance is a complete middleware and 
 routing system; for this reason, it is often referred to as a “mini-app”.

 -----------------------------------------------------------------------------------
recommended
FOR EXPRESS ROUTE SPECIFIC

for - /login  OR /register POST routes

bodyParser.urlencoded({ extended: true })
-----------------------------------------------------------------------------------

ONLY SEND the id and username as response not full user(with passwords)

INBUILT express body-parser not working(task)

handlers/auth.js

const user = await db.User.create(req.body);

// destructure the user
const {id, username} = user;

res.json({id, username});

-----------------------------------------------------------------------------------
Status Codes

500 -> Internal server is broken
400 -> Something went wrong
200 -> OK
201 -> Something was created

mongoose specific error code
11000 => that field is already taken or in use(example creating a user with same name)

-----------------------------------------------------------------------------------


Authenticate => middleware(auth.js)

jwt.verify(token, process.env.SECRET, (error, decoded) => {
            if(error){
                next(Error('Failed to Authorize Token'))

            }else{
                //add decoded field to req object if authorized/verified
                
                //sending the users data to the next function to be used
                // only one middle ware for authorisation and authentication
                // coukd be used to check if user is logged in 
                // if we want to know the specific users who is logged in => done via decoded property of req
                req.decoded = decoded;
                next();
            }
        })
    }else{
        next(Error('No Token Provided'));
    }


-----------------------------------------------------------------------------------
async function => try catch block


-----------------------------------------------------------------------------------

DIFFERENCE BETWEEN app.get('/') and router.get('/')
https://stackoverflow.com/questions/28305120/differences-between-express-router-and-app-get

router.get('/') => is its own mini app seperate from the main app
Each file's router becomes a mini app, which has a very similar structure to the main app.


If you have code (middleware) that pertains to all three routes, you can put it in the main app, 
before the app.use(...) calls. If you have code (middleware) that pertains to just one of those routes, 
you can put it in the file for that route only.



-----------------------------------------------------------------------------------

map() in js
Ref = https://www.w3schools.com/jsref/jsref_map.asp

The map() method creates a new array with the results of calling a function for every array element.

The map() method calls the provided function once for each element in an array, in order.

Note: map() does not execute the function for array elements without values.

Note: this method does not change the original array.

EXAMPLE - 
Multiply all the values in array with 10:

var numbers = [65, 44, 12, 4];
var newarray = numbers.map(myFunction)

function myFunction(num) {
  return num * 10;
}

-----------------------------------------------------------------------------------
handlers/poll.js => createPoll

 poll object = {
             question: (string),
             options: 
                      [ 
                        {option: 'this is option 1', votes : 0}, 
                        {option: 'this is option 2,', votes: 0}
                      ] 
                }
        options: array of objects with properties option and  votes(defualt = 0)


 EVERY MONGOOSE SCHEMA HAS ITS OWN UNIQUE ID => by default       

-----------------------------------------------------------------------------------







